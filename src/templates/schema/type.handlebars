{{#*inline "fieldsClass" }}
{{ multilineComment description }}
class {{ className }}  {{

  classExtends
    mixins=(resolveMixins @root.config.mixins fields)
    fragments=fragmentsSpread
    interfaces=(wrapFields interfaces)
    replace=@root.config.replaceTypes

}} {

  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{ resolveType type
      "inline"
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      @root.config.scalars
      @root.config.replaceTypes
      isArray
      @root.config.irreducibleTypes
      raw
      ../name
      @root.config.requiredFields
  }} {{ dartName name }};
  {{~/if}}{{/if}}{{/each}}

  {{ className }}({
    {{#each fields}}{{#if name}}
        this.{{ dartName name }},
    {{/if}}{{/each}}
  });
    /// Adds all fields from [other] to this `{{ className }}`.
    /// 
    /// If a field from [other] is already in this `{{ className }}`,
    /// its value is not overwritten, unless  `overwrite: true` is specified
    void addAll(covariant {{ className }} other, { bool overwrite = true, }) {
        assert(other != null, "Cannot add all from null into $this");
        if (overwrite != null && overwrite){
            {{#each fields}}{{#if name}}
            {{ dartName name }} = other.{{ dartName name }} ?? {{ dartName name }};
            {{~/if}}{{/each}}
        } else {
            {{#each fields}}{{#if name}}
            {{ dartName name }} ??= other.{{ dartName name }};
            {{~/if}}{{/each}}
        }
    }

  /// Creates a copy of this `{{ className }}` but with the given fields replaced with the new values.
  {{ className }} copyWith(
  {{~#if fields.length~}}
    {
        {{~#each fields}}
        {{#if type}}{{#if name}}
            {{ resolveType type
                "inline"
                (takeFirst contextName ../contextName)
                (takeFirst contextModels ../contextModels)
                @root.config.scalars
                @root.config.replaceTypes
                isArray
                @root.config.irreducibleTypes
                raw
                ../className
                @root.config.requiredFields
            }} {{ dartName name}},
        {{~/if}}{{/if}}{{/each}}
    }
  {{~/if~}}
    ){
        return {{ className }}(
            {{#each fields}}{{#if type}}{{#if name}}
            {{ dartName name}}: {{ dartName name}} ?? this.{{ dartName name}},
            {{~/if}}{{/if}}{{/each}}
        );
  }

  /// Creates a copy of this `{{ className }}`
  {{ className }} copy() => copyWith();

}
{{/inline}}

{{#unless (
  ignoreType
    name
      @root.config.replaceTypes
      typeName
      @root.config.irreducibleTypes
)}}

{{> fieldsClass this className=(concat "_" name "Fields") }}

class {{ name }} {{

  classExtends
    mixins=(resolveMixins @root.config.mixins fields)
    fragments=fragmentsSpread
    interfaces=interfaces
    replace=@root.config.replaceTypes

}} {
  static final String typeName = "{{ takeFirst typeName name }}";

  @protected
  covariant _{{ name }}Fields fields;

  {{name}}({
    {{#each fields}}{{#if name}}
        {{ resolveType type
            "inline"
            (takeFirst contextName ../contextName)
            (takeFirst contextModels ../contextModels)
            @root.config.scalars
            @root.config.replaceTypes
            isArray
            @root.config.irreducibleTypes
            raw
            ../name
            @root.config.requiredFields
        }} {{ dartName name }},
    {{/if}}{{/each}}
  }): fields = _{{ name }}Fields(
    {{#each fields}}
    {{ dartName name }}: {{ dartName name }},
    {{/each}}
  );


    @protected
    Set<String> get missingRequiredFields {
        Set<String> missingFields = Set();
        {{#each fields}}
        {{~#if isRequired}}
        if (fields.{{ dartName name }}  == null){
            missingFields.add("{{ dartName name }}");
        }
        {{/if}}
        {{/each}}
        return missingFields;
    }

    void validate(){
        final missing = missingRequiredFields;
        assert(missing.isEmpty, "$runtimeType#$hashCode is missing required fields $missing"); 
    }

    bool get isValid => missingRequiredFields.isEmpty;


}

{{/unless}}